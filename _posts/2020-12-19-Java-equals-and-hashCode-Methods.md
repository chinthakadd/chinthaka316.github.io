---
layout: post
title: Refresh Memory While Having a Deeper Look at Java equals() and hashCode() Methods
---

I was writing a small piece of code for a Proof of Concept, and required to write an equals method and was wondering if I had given thought to it in my career of 8 years. Yes I know it, but do I really know it enough. This was the revision exercise I did, which I thought of sharing as an simplistic article with everyone. 

These are two very important methods that all Java developers are well aware of. And it is such a basic topic, but may be due to the simplicity of the concept, and also due to the fact that IDEs that we use today generate them very nicely, we tend to forget or overlook it. So I thought of documenting some details around it.

One of the best chapters I have read about these two methods and few others were in `Chapter 03` of the book `Effective Java` by `Joshua Bloch`.

In this article, I capture some of the important aspects of these two methods that I have learned.

## Equals - Covering Basics

Lets start with Equality of Objects in Java. We know that equality of objects is evaluated using the `equals` method. By default, in Java, we say that two objects are equal, if the Object References (let's say obj1 and obj2) are referring to the same object (in memory). Now we know Java `Object` class provides an implementation to this.

```java
public boolean equals(Object obj) {  
    return (this == obj);  
}
```

Pretty straight forward. But this does not suffice our needs in most cases when we exercise Object Oriented Programming.  Given that equality of instances of classes must be defined by their attributes and not based on the memory locations where they are stored, we must override this method.

However, there are few rules that we need to be aware in doing this. 

Just the basics first. Know and understand what equality means. It is important that we ensure that all the below properties of equality are maintained by our implementation.

- Reflexive - For any object reference `obj`, obj.equals(obj) must be `true`

- Symmetric - For any two equal objects, `obj1` and `obj2`, obj1.equals(obj2) and obj2.equals(obj1) both must return `true`.

- Transitive - For `obj1`  `obj2` and `obj3` if obj1.equals(obj2) is true, and obj2.equals(obj3) is true, then obj1.equal(obj3) must be `true`.

- Consistent - Given that attributes that are part of the equality logic remains unchanged, all subsequent equals() invocation of the same equal objects must continue to return `true`.

## Equals - Ways to Implement

### Codified Way - Every Java Developer Must Know

The following is a hand coded implementation for `equals` method on `Passport` class.

```java

/**  
 * Assume that passports are equal only if their number and name matches. 
 */
 public class Passport {  
  
 private String number;  
 private String name;  
 private String country;  
  
 @Override  
 public boolean equals(Object o) {  
        // Shallow Check  
 		if (this == o) return true;  
 		// if not from same class, not equal.  
 		if (o == null || !o.getClass().equals(Passport.class)) return false;  
 		Passport passport = (Passport) o;  
 		// NOTE: Null safe equality check using Objects.equal().  
 		// If any of the value is null, it will return false,
		// if both are null, it will return true. 
		return Objects.equals(number, passport.number) && Objects.equals(name, passport.name);  
 }  
 
 ....
}

```

The same can be generated by IDEs such as Intelij, however, probably in an interview or a situation where you don't have that luxury, it is important that you are on top of this.

- Using an Utility Library

Also, common utility libraries such as Apache `Commons` provides builders to implement it easily.

ex: Using Apache Commons (which uses reflections to perform equal check using attributes of the object. This could be the default implementation of a base class (`BaseDto`, `BaseModel` or `BaseEntity`))

```java
 public boolean equals(Object obj) {
   return EqualsBuilder.reflectionEquals(this, obj);
 }
```

- Using `Lombok` to generate the code

Now, if you are using Java, but hate boilerplate, probably you are already a fan of `lombok`. It provides a nice annotations called `@EqualsAndHashCode` which can use the generate both `equals` and `hashCode` methods automatically. 

- If you use `kotlin`, use `data` classes that generates `equals` and `hashCode`

Data classes are one of those syntax sugar conveniences that makes us fall in love with the `Kotlin`. What Lombok does with Java, Data classes does it automatically in Kotlin. It generates equals / hashCode() pair based on the attributes defined in the `primary` constructor.

ex: 

```kotlin
data class User(val name: String, val age: Int)
```

equals() and hashCode() for the above will be generated based on `name` and `age` attributes.


Now lets talk about the contract between `equals()` and `hashCode()`. The moment we change the logic of the equality operation, we need to ensure that hashCode() method contract still stands.

## HashCode - Covering Basics

Why is hashCode() method so important? 

As we all know, hashCode() is used in Java's Collections that uses `Hashing` mechanism as a way to minimize the performance cost of operations such as add, get, remove and etc. Examples are HashTable, HashMap and HashSet.

What is the contract between hashCode() and equals() ? 

If two objects are equal, their hashCode() value must be the same. This the rule of thumb.
However, if hashCode() values of two objects are the same, it does not mean that those two objects must be equal. It could be, but does not have to be. It all depends on how the developers have implemented the hashCode() method.

Now the Rule of Thumb prescribed above is so important. Because if you don't abide to this rule, it could lead to inconsistent results specially when you use HashSet like implementations. 

Example below:

```java
/**  
 * Assume that passports are equal only if their number and name matches. 
 */
 public class Passport {  
  
    private String number;  
 	private String name;  
 	private String country;  
  
 	public Passport(String number, String name) {  
        this.number = number;  
 		this.name = name;  
 	}  
  
    @Override  
 	public final boolean equals(Object o) {  
        // Shallow Check  
 		if (this == o) return true;  
 		// if not from same class, not equal.  
 		if (o == null || !o.getClass().equals(Passport.class)) return false;  
 		Passport passport = (Passport) o;  
 		// NOTE: Null safe equality check using Objects.equal().  
 		// If any of the value is null, it will return false, // if both are null, it will return true. return Objects.equals(number, passport.number) && Objects.equals(name, passport.name);  
 }  
   
 	public static void demoImportanceOfHashMap(){  
        Passport p1 = new Passport("123", "Chinthaka");  
 		Passport p2 = new Passport("123", "Chinthaka");  
 		// Prove that they are equal  
 		System.out.println(p1.equals(p2)); // returns true.  
  
 		// Lets add them to a HashSet Set<Passport> set = new HashSet<>();  
 		set.add(p1);  
 		set.add(p2);  
  
 		System.out.println("P1 HashCode:" + p1.hashCode());  
 		System.out.println("P2 HashCode:" + p2.hashCode());  
  
 		// Assumption is the size should be 1  
 		System.out.println("Set Size: " + set.size());  
 	}  
  
 	public static void main(String[] args) {  
        demoImportanceOfHashMap();  
 	}  
}

```

The output was:

```
true
P1 HashCode:356573597
P2 HashCode:1735600054
Set Size: 2
```

As you see, even if two objects are equal, but their hash codes are not the same, they will not be considered equal in an `HashSet` (because `hashCode()` is invoked first and based on that only, an `equals()` operation will be executed IF there are multiple elements in a particular hash bucket) and therefore you would see duplicates. This is catastrophic.

Another code smell of a hashCode() is when there are too much hash collisions. As written in `HashMap` Java Documentation, having too many different Objects (unequal) returning the same hash code is a sure way for reducing performance as it increases the number of elements of a particular Hash Bucket where the object is stored.

Refer the below snippet from Java `HashMap.getNode(int hash, Object key)`  implementation.

```java

do {  
    if (e.hash == hash &&  
        ((k = e.key) == key || (key != null && key.equals(k))))  
        return e;  
} while ((e = e.next) != null);

```

Java `Object` class provides a default implementation for the `hashCode()` method. How does Java implement hashCode?

```java
public native int hashCode();
```

The `native` keyword here indicates that this is not a Java implementation, it is written using low level language (C) and then injected to Java using JNI (Java Native Interface) technique. So we will not be able to see how the implementation looks like here.

The default implementation of the hashCode() is based on the memory address of the Object.  Reading through the native code (provided in the reference below), it further proves that it is uses different techniques such as MD5, CRC32, DES/AES and XOR Shifting to generate the hash code value based on the memory address. Knowing what really goes beneath our JVM, though it is tough to fully perceive, is certainly interesting. Refer to the links I have provided below.

So how do we override and implement the hashCode() properly for a class which already has a custom equals() implementation.

### Codified Way - Every Java Developer Must Know

This is based on the guidance provided by `Joshua Bloch` in `Chapter 03` of `Effective Java` book.

For the hash code to be distinctive as possible across different objects making it an effective hashCode() implementation, the following steps needs to be followed.

- Store a non-zero value as the result. (Any random number)
- Then for each field that is considered in the equals() implementation, calculate their hashcode and them to the multiplication of current result by 31.

Refer an implementation of it below for the `Passport` class.

```java

/**  
 * 
 * Instead of generating the hash code on based on the Object's Memory Reference (JNI), 
 * generate it based on the attributes that are involved in the equality check. 
 * 
 * @return 
 */  
@Override 
public int hashCode() {  
    int result = 17;  
	result = 31 * result + number == null? 0: number.hashCode();  
	result = 31 * result + name == null? 0: name.hashCode();
	return result;  
}

```

why a random number at the start? Zero cannot be used as it would lead to collisions. Specially when the hash code of the fields that are participating in this would also return 0 in their hash code calculation. For Example, boolean false value would generally have 0 as the hash code. Also if a particular field is null, typically 0 is returned (as depicted in the code). Having a non-zero number as the initial seed reduces the potential conflicts due to that reason.

NOTE: However `Boolean` Java class does not return 0 (false) or 1 (true) for hashCode. Instead arbitrary numbers of `1231` and `1237` are used.

Why multiply by number 31?

The reason is that it makes the hashCode() calculation depend on the order of the fields. Great example from `Effective Java` book that I like to quote here is:

"For example, if the multiplication were omitted from a `String` hash function, all anagrams would have identical hash codes."

I wondered why number 31 and the good reason that I found from that chapter is, multiplication by 31 can be replaced by a Shift and a Subtraction (`31 * i == (i << 5) - i`) and modern VMs seems to do this optimization for us.

### Using `Objects.hash(Object... values)`
This is an utility method provided in Java `Objects` library which takes cares of generating a hashCode following the above mentioned techniques applied with all the participating fields.

Also, as mentioned above, `Lombok` for Java would auto-generate this for you with `EqualsAndHashCode` annotation. Similarly in Kotlin, Data Classes automatically generate this for you.

As Java programmers, we no longer may really pay too much attention this. But the importance of equals() and hashCode() method combination remains the same, specially when you are building frameworks and components that other teams will rely on in the future.

## References

- Apache Commons EqualsBuilder - https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/EqualsBuilder.html

- Lombok - https://projectlombok.org/features/EqualsAndHashCode

- Kotlin Data Classes - https://kotlinlang.org/docs/data-classes.html

- Good Discussion on Java's HashCode implementation
	-  https://stackoverflow.com/questions/13602501/whats-the-implementation-of-hashcode-in-java-object

- Found source code for Java Native Hash Code Implementation here - https://stackoverflow.com/questions/10578764/why-are-hashcode-and-getclass-native-methods

- C Code for Java's HashCode Implementation
	- http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/tip/src/share/vm/prims/jvm.cpp (JVM_ENTRY(jint, JVM_IHashCode...), line 504)
	- http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/tip/src/share/vm/runtime/synchronizer.cpp (FastHashCode, Line 576 and get_next_hash, line 530)